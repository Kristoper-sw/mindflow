# 工作流卡住问题修复说明

## 问题描述
工作流执行时经常卡住，有时可以完全完成，有时会在初始阶段就停止，表现为间歇性故障。

## 根本原因

### 1. **数据库事务提交时机问题（主要原因）**
- **问题**：API 服务在创建工作流实例时，在数据库事务提交**之前**就发送了 Kafka 消息
- **影响**：Orchestrator 收到消息并查询数据库时，事务还未提交，导致查询不到节点实例（返回 0 个节点）
- **日志证据**：
  ```
  17:29:21.657 [API] 已发送工作流创建事件到 Kafka
  17:29:21.659 [Orchestrator] 收到工作流创建事件 (仅 2ms 后)
  17:29:21.667 [Orchestrator] 查询到 0 个节点实例
  ```

### 2. **Kafka 消息发送未等待确认**
- **问题**：使用 `kafkaTemplate.send()` 异步发送消息，没有等待发送确认
- **影响**：如果 Kafka 发送失败，不会有任何错误处理，消息会丢失

### 3. **节点状态更新时机不当**
- **问题**：先更新节点状态为 RUNNING，再发送 Kafka 消息
- **影响**：如果消息发送失败，节点状态已经变为 RUNNING，但实际没有任务被执行

### 4. **缺少关键调试日志**
- **问题**：没有记录入口节点数量、节点实例是否存在等关键信息
- **影响**：难以定位问题原因

## 修复方案

### 1. ✅ 修复事务提交时机（WorkflowService.java）
**修改前：**
```java
@Transactional
public Long createWorkflowInstance(...) {
    // 创建节点实例
    nodeInstanceRepository.save(nodeInstance);
    
    // 立即发送 Kafka 消息（事务未提交）
    kafkaTemplate.send(WORKFLOW_CREATED_TOPIC, message);
    
    return instance.getId();
} // 事务在这里提交
```

**修改后：**
```java
@Transactional
public Long createWorkflowInstance(...) {
    // 创建节点实例
    nodeInstanceRepository.save(nodeInstance);
    
    // 注册事务提交后回调
    TransactionSynchronizationManager.registerSynchronization(
        new TransactionSynchronization() {
            @Override
            public void afterCommit() {
                // 事务提交后才发送消息
                kafkaTemplate.send(WORKFLOW_CREATED_TOPIC, message).get();
                logger.info("事务提交后成功发送工作流创建事件");
            }
        });
    
    return instance.getId();
}
```

### 2. ✅ Kafka 消息同步发送并等待确认
**修改文件：**
- `WorkflowEventConsumer.java`
- `NodeCompletionConsumer.java`
- `TaskConsumerService.java`

**修改内容：**
```java
// 修改前：异步发送，不等待
kafkaTemplate.send(TASK_TOPIC, taskMsg);
nodeInstance.setStatus("RUNNING");

// 修改后：同步发送，等待确认后再更新状态
try {
    kafkaTemplate.send(TASK_TOPIC, taskMsg).get(); // 等待发送完成
    logger.info("成功推送任务到 Kafka");
    
    // 发送成功后才更新状态
    nodeInstance.setStatus("RUNNING");
    nodeInstance.setStartTime(LocalDateTime.now());
    nodeInstanceRepository.save(nodeInstance);
} catch (Exception e) {
    logger.error("推送任务失败: {}", e.getMessage());
    nodeInstance.setStatus("FAILED");
    nodeInstanceRepository.save(nodeInstance);
}
```

### 3. ✅ 增强日志记录
**添加的关键日志：**
- 入口节点数量和列表
- 查询到的节点实例数量
- 节点配置/实例是否找到
- Kafka 发送成功/失败的详细信息
- 节点状态更新确认

## 测试建议

### 1. 验证事务提交修复
- 观察日志中 "事务提交后成功发送工作流创建事件" 出现
- 确认 Orchestrator 查询节点实例时返回正确数量（不再是 0）

### 2. 验证消息可靠性
- 检查所有 Kafka 发送是否都有 "成功推送" 日志
- 模拟 Kafka 故障，确认能正确标记节点为 FAILED

### 3. 压力测试
- 连续创建多个工作流实例
- 确认不再出现间歇性卡住问题

## 预期日志输出

修复后的正常日志流程：
```
[API] 创建工作流实例: workflowDefinitionId=2
[API] insert into node_instance ... (3次)
[API] 已注册事务提交后回调
[API] 事务提交后成功发送工作流创建事件到 Kafka: instanceId=25

[Orchestrator] 收到工作流创建事件
[Orchestrator] 找到 1 个入口节点: [node1]
[Orchestrator] 查询到 3 个节点实例  ← 关键：不再是 0
[Orchestrator] 成功推送任务到 Kafka: nodeId=node1
[Orchestrator] 已更新节点状态为 RUNNING: nodeId=node1

[Worker] 收到任务消息
[Worker] 任务执行完成: nodeId=node1, status=SUCCESS
[Worker] 成功发送节点完成事件到 Kafka
```

## 涉及的文件

1. **mindflow-api/src/main/java/com/mindflow/api/service/WorkflowService.java**
   - 使用事务提交后回调发送 Kafka 消息

2. **mindflow-orchestrator/src/main/java/com/mindflow/orchestrator/service/WorkflowEventConsumer.java**
   - 同步发送 Kafka 消息
   - 增强日志记录

3. **mindflow-orchestrator/src/main/java/com/mindflow/orchestrator/service/NodeCompletionConsumer.java**
   - 同步发送 Kafka 消息
   - 改进错误处理

4. **mindflow-worker/src/main/java/com/mindflow/worker/service/TaskConsumerService.java**
   - 同步发送 Kafka 消息
   - 改进错误处理

## 注意事项

1. **性能影响**：使用 `.get()` 会阻塞等待 Kafka 确认，会轻微增加响应时间（通常几毫秒到几十毫秒）
2. **可靠性提升**：确保消息不会丢失，状态一致性得到保障
3. **重新编译**：需要重新编译并重启所有服务（api、orchestrator、worker）

## 编译和部署

```bash
# 编译所有模块
cd D:\Code\mindflow
mvn clean package

# 重启服务（使用 docker-compose）
docker-compose down
docker-compose up -d --build
```


